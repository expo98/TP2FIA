\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage{titling}
\newcommand{\subtitle}[1]{%
  \posttitle{%
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.5em}%
}
\usepackage{graphicx}
\usepackage[inkscapelatex=false]{svg}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{tocloft} % For customizing the TOC
\usepackage{booktabs}

% to display the code
\usepackage{listings}
\usepackage{xcolor}
\lstdefinestyle{python}{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{red},
    commentstyle=\color{gray}\itshape,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    frame=single,
    breaklines=true,
    tabsize=4,
    backgroundcolor=\color{gray!10},
}
\lstset{style=python}

% to display the graphs
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}


\title{\textbf{Lunar Lander}}
\subtitle{Project \#2 for Artificial Intelligence Fundamentals}

\author{Francisco Silva, Miguel Pereira and Guilherme Rodrigues 
\\ Nº 2022213583, 2022232552 and 2022232102 \\ \\
Department of Informatics Engineering \\
University of Coimbra, Coimbra, Portugal
\\ \textbf{\{francisco.lapamsilva,miguelmpereira0409,gfr04\}}@gmail.com}

\date{May 18th, 2025}

\begin{document}

\maketitle

\newpage
\tableofcontents
\newpage

\section{Methodology}
\subsection{Perceptions}
We utilize the following perception variables to determine the lander's state:

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Symbol} & \textbf{Description} \\
\midrule
x & Horizontal position (0 at platform center) \\
y & Vertical position (0 at platform surface) \\
Vx & Horizontal velocity (positive rightward) \\
Vy & Vertical velocity (positive upward) \\
A & Angular direction (positive counter-clockwise) \\
Va & Angular velocity (positive counter-clockwise) \\
L & Left leg ground contact (1 if touching) \\
R & Right leg ground contact (1 if touching) \\
\bottomrule
\end{tabular}
\caption{Perception Variables and Descriptions}
\end{table}

\subsection{Actions}
To control the it's descent, the Lander uses two motors: main motor (mM) and lateral motors (lM), whose values range from 0.0$\rightarrow$1.0 and -1.0$\rightarrow$1.0.
These two controls are represented and controlled by the two output neurons, as seen in the "network" function.
When the mM's value is greater than 0.5, the motor is on. When the lM's value is lesser than -0.5, the left motor activates, and when it is greater than 0.5, the right motor activates.
\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Symbol} & \textbf{Description} \\
\midrule
mM & main Motor \\
lM & lateral Motor \\
\bottomrule
\end{tabular}
\caption{Perception Variables and Descriptions}
\end{table}

\subsection{Objective Function}
The most important mechanism of our evolution is the Objective Function. It is also the part that has undergone the biggest change throughout development.
Our Objective Function is designed to evaluate the lander and guide it to a successful landing by rewarding stability, position, and landing.

We started with the simple goal of stabilizing the lander. The first version of the OF looks like this:
\begin{lstlisting}
def objective_function(observation):
    fitness = 0

    x = observation[0]
    y = observation[1]
    x_speed = observation[2]
    y_speed = observation[3]
    angle = observation[4]
    angle_speed = observation[5]
    left_leg_touching = observation[6]
    right_leg_touching = observation[7]

    #stability
    stable_angle = (25-(angle)**2) / 25
    stable_angle_speed = int(abs(angle_speed) < 1.5)

    stable_horizontal_speed = int(abs(x_speed) < 0.1)   # Neste caso é melhor discreto
    stable_vertical_speed = (10-(y_speed+0.2)**2) / 10  # Offset de -0.2 (velocidade desejada de -0.2)

    stability = (
        500* stable_angle +
        400* stable_angle_speed +
        200* stable_horizontal_speed +
        300* stable_vertical_speed
    )



    fitness = (
        stability
    )

    return fitness, check_successful_landing(observation)
\end{lstlisting}

Some noteworthy aspects of this code are our early decision to make each rule return values normalized between 0 and 1 that are then multiplied by a weight to balance the importance of different rules, and the utilization of constant functions instead of discrete, to better guide the lander to the desirable state smoothly.

\begin{figure}[h]
    \centering
    % Top-left: stable_angle
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                domain=-5:5,
                samples=100,
                axis lines=middle,
                xlabel={A},
                ylabel={stable\_angle},
                width=0.95\textwidth,
                height=0.6\textwidth,
                ymin=-1.2, ymax=1.2,
                xmin=-5, xmax=5,
                grid=both,
                legend style={at={(0.5,-0.15)},anchor=north},
            ]
            \addplot[blue, thick] {(25 - (x)^2)/25};
            \addlegendentry{$(25-\mathrm{angle}^2)/25$}
            \end{axis}
        \end{tikzpicture}
        \caption{stable\_angle}
    \end{minipage}
    \hfill
    % Top-right: stable_angle_speed
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                domain=-3:3,
                samples=100,
                axis lines=middle,
                xlabel={Va},
                ylabel={stable\_angle\_speed},
                width=0.95\textwidth,
                height=0.6\textwidth,
                ymin=-0.2, ymax=1.2,
                xmin=-3, xmax=3,
                grid=both,
                legend style={at={(0.5,-0.15)},anchor=north},
            ]
            \addplot[red, thick, samples=2, domain=-3:-1.5] {0};
            \addplot[red, thick, samples=2, domain=-1.5:1.5] {1};
            \addplot[red, thick, samples=2, domain=1.5:3] {0};
            \addlegendentry{$\mathrm{int}(|\mathrm{angle\_speed}| < 1.5)$}
            \end{axis}
        \end{tikzpicture}
        \caption{stable\_angle\_speed}
    \end{minipage}
    \vspace{1em}

    % Bottom-left: stable_horizontal_speed
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                domain=-0.5:0.5,
                samples=2,
                axis lines=middle,
                xlabel={Vx},
                ylabel={stable\_horizontal\_speed},
                width=0.95\textwidth,
                height=0.6\textwidth,
                ymin=-0.2, ymax=1.2,
                xmin=-0.5, xmax=0.5,
                grid=both,
                legend style={at={(0.5,-0.15)},anchor=north},
            ]
            \addplot[green, thick, samples=2, domain=-0.5:-0.1] {0};
            \addplot[green, thick, samples=2, domain=-0.1:0.1] {1};
            \addplot[green, thick, samples=2, domain=0.1:0.5] {0};
            \addlegendentry{$\mathrm{int}(|\mathrm{x\_speed}| < 0.1)$}
            \end{axis}
        \end{tikzpicture}
        \caption{stable\_horizontal\_speed}
    \end{minipage}
    \hfill
    % Bottom-right: stable_vertical_speed
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                domain=-3:3,
                samples=100,
                axis lines=middle,
                xlabel={Vy},
                ylabel={stable\_vertical\_speed},
                width=0.95\textwidth,
                height=0.6\textwidth,
                ymin=-1.2, ymax=1.2,
                xmin=-3, xmax=3,
                grid=both,
                legend style={at={(0.5,-0.15)},anchor=north},
                ]
                \addplot[green, thick] {(10 - (x + 0.02)^2)/10};
                \addlegendentry{$(10 - (v_y + 0.02)^2)/10$}
            \end{axis}
        \end{tikzpicture}
        \caption{stable\_vertical\_speed}
        \label{fig:stable_vertical_speed}
    \end{minipage}
\end{figure}

As shown in Figure~\ref{fig:stable_vertical_speed}, in the stable\_vertical\_speed function, we added a small offset of $-0.2$ to encourage the lander to descend at a speed of $-0.2$, which is the desired speed for landing. This adjustment helps prevent the lander from stopping completely or ascending.
This allows us to not have to add a separate rule to encourage the lander to descend, as it is already being done by the stable\_vertical\_speed function.




\subsection{Genetic Operators}

\subsubsection{Parent Selection Methods}

Two different strategies for selecting parents were implemented and can be interchanged through the \texttt{PARENT\_SELECTION} variable.

\paragraph{Fitness-Proportionate Selection (Roulette Wheel)}
The \texttt{parent\_selection} function selects individuals with a probability proportional to their fitness. The total fitness of all positively fit individuals is calculated and a random probability is drawn. The algorithm iterates through the population, subtracting each individual's fitness contribution from the probability until one is selected. If the total positive fitness is zero or negative, a random individual is returned to avoid failure. This method ensures that individuals with higher fitness are more likely to be chosen while still giving a chance to less fit individuals.

\paragraph{Tournament Selection}
The \texttt{parent\_selection\_tournament} function implements a simple tournament selection: two individuals are randomly selected from the population, and the one with the highest fitness is chosen as the parent. This method introduces selective pressure by favoring the fitter of two candidates but without requiring any normalization of fitness values.

\paragraph{Current Strategy}
The evolutionary process currently uses the \texttt{tournament selection} strategy as the active method, set by:
\begin{verbatim}
PARENT_SELECTION = parent_selection_tournament
\end{verbatim}
This can be easily changed to the fitness-proportionate version if desired, providing flexibility to test different selection dynamics. We implemented and tested both approaches and observed that while tournament selection consistently yielded better results, the fitness-proportionate method also performed well in practice. For this reason, we decided to retain both implementations to allow further experimentation and adaptability in different scenarios.

\subsection{Crossover}
The \texttt{crossover} function is responsible for generating a new individual (offspring) from two parent individuals, using a single-point crossover method. This is a standard technique in genetic algorithms where a random point is chosen along the genotype vector, and the offspring inherits genes from one parent up to that point and from the other parent after that point.

The function starts by randomly selecting a crossover point between 1 and \texttt{GENOTYPE\_SIZE - 1}, ensuring that both parents contribute at least one gene to the offspring. Then, it randomly chooses which parent will contribute the first part and which one will contribute the second. This is done by generating a random number and comparing it with 0.5.

Depending on the order chosen, the function constructs the offspring's genotype by taking the first part from one parent and the second part from the other using list slicing. The result is a new genotype that is a mixture of the genetic material of both parents.

Finally, the function returns a new individual represented as a dictionary with the newly generated genotype and a \texttt{None} fitness value, indicating that the individual has not yet been evaluated.

This implementation introduces genetic diversity while preserving genetic information from the parents, which is essential for effective exploration of the solution space.

\subsection{Mutation}
\subsection{Survival Selection}
\subsection{Evolution}

\subsection{Algorithm Parameters}
\begin{itemize}
    \item Population size: 100 individuals
    \item Generations: 100
    \item Crossover probability: 50\%
    \item Elite size: 1 individual
\end{itemize}

\section{Experimentation and Results}
\subsection{Milestone 1: Windless Environment}
Performance comparison of tested configurations:

\begin{table}[h]
\centering
\caption{Configuration Performance (Milestone 1)}
\begin{tabular}{@{}lcc@{}}
\toprule
Configuration & Average Success Rate & Average Fitness \\ 
\midrule
Experiment 1 & 68\% & 142 \\
Experiment 3 & 82\% & 156 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Milestone 2: Windy Environment}
Adaptations for wind conditions (15W):
\begin{itemize}
    \item Enhanced architecture: (8,16,2)
    \item Horizontal oscillation penalties
    \item Achieved success: 74\% with fitness 138
\end{itemize}

\section{Conclusions}
The evolutionary algorithm proved effective, though wind introduction required:
\begin{itemize}
    \item Increased neural network capacity
    \item Objective function adjustments
    \item Maintained genetic diversity
\end{itemize}

\end{document}